import { JiraProject, JiraUser, JiraSearchResult } from '../services/mcpJiraService.js';

export interface DatabaseUser {
    id?: number; // Auto increment, optional for inserts
    display_name?: string;
    email_address?: string;
    active: boolean; // Required, not optional
}

export interface DatabaseProject {
    id: string;
    key: string;
    name: string;
    self: string;
    project_type_key?: string;
    archived?: boolean;
    project_category_self?: string;
    project_category_id?: string;
    project_category_name?: string;
    project_category_description?: string;
}

export interface DatabaseStatus {
    id: string;
    name: string;
    description?: string;
    status_category: string;
}

export interface DatabaseComponent {
    id: string;
    name: string;
    description?: string;
    self: string;
    issue_id: string;
}

export interface DatabaseFixVersion {
    id: string;
    self: string;
    name: string;
    description?: string;
    archived: boolean;
    released: boolean;
    release_date?: Date;
    project_id: string;
}

export interface DatabaseIssue {
    id: string;
    key: string;
    self: string;
    summary: string;
    status_name?: string;
    project_id: string;
    project_key?: string;
    project_name?: string;
    assignee_name?: string;
    reporter_name?: string;
    issue_type_name?: string;
    priority_name?: string;
    created: Date;
    updated: Date;
    resolved_date: Date | null; // Can be null if not resolved
    description?: string;
    labels?: string; // JSON string
    subtasks?: string; // JSON string
    changelog?: string | null; // JSON string - store changelog data, can be null
}

export interface DatabaseChangelog {
    id?: number; // AUTO_INCREMENT, optional for inserts
    issue_id: string;
    created: Date; // When the status change happened
    author_name: string;
    author_email: string;
    from_status?: string; // Previous status name
    to_status?: string; // New status name
    from_id?: string; // Previous status ID
    to_id?: string; // New status ID
    created_at?: Date; // TIMESTAMP, auto-generated
    updated_at?: Date; // TIMESTAMP, auto-generated
}

export interface DatabaseSubtask {
    id: string;
    name: string;
    self: string;
    issue_id: string;
}

export interface DatabaseLabel {
    issue_id: string;
    label_name: string;
}

export interface DatabaseIssueFixVersion {
    issue_id: string;
    fix_version_id: string;
}

export interface DatabaseComment {
    id?: number; // AUTO_INCREMENT, optional for inserts
    issue_id: string;
    comment_id: string; // Jira comment ID
    author_name: string;
    author_email: string;
    body: string;
    created: Date;
    updated: Date;
    created_at?: Date; // TIMESTAMP, auto-generated
    updated_at?: Date; // TIMESTAMP, auto-generated
}

export class JiraDataMapper {
    // Helper function to convert undefined to null for MySQL compatibility
    private static nullify(value: any): any {
        return value === undefined ? null : value;
    }

    // Map Jira user to database user
    static mapUser(jiraUser: JiraUser): DatabaseUser {
        // Handle company MCP server format where name/email exist
        const userEmail = jiraUser.emailAddress || (jiraUser as any).email;
        const userDisplayName = jiraUser.displayName || jiraUser.name;

        const result: DatabaseUser = {
            // id will be auto-generated by database
            display_name: this.nullify(userDisplayName),
            email_address: this.nullify(userEmail),
            active: jiraUser.active ?? true // Default to true if undefined
        };

        return result;
    }

    // Map Jira project to database project
    static mapProject(jiraProject: JiraProject): DatabaseProject {
        const result: DatabaseProject = {
            id: this.nullify(jiraProject.id),
            key: this.nullify(jiraProject.key),
            name: this.nullify(jiraProject.name),
            self: this.nullify(jiraProject.self),
            project_type_key: this.nullify(jiraProject.projectTypeKey),
            archived: jiraProject.archived ?? false,
            project_category_self: this.nullify(jiraProject.projectCategory?.self),
            project_category_id: this.nullify(jiraProject.projectCategory?.id),
            project_category_name: this.nullify(jiraProject.projectCategory?.name),
            project_category_description: this.nullify(jiraProject.projectCategory?.description)
        };

        return result;
    }

    // Map Jira issue status to database status
    static mapStatus(jiraStatus: any): DatabaseStatus {
        return {
            // Use name as id if id is null (for company MCP server compatibility)
            id: this.nullify(jiraStatus.id || jiraStatus.name),
            name: this.nullify(jiraStatus.name),
            description: this.nullify(jiraStatus.description),
            status_category: this.nullify(JSON.stringify(jiraStatus.statusCategory || {}))
        };
    }

    // Map Jira component to database component
    static mapComponent(jiraComponent: any, issueId: string): DatabaseComponent {
        return {
            id: jiraComponent.id,
            name: jiraComponent.name,
            description: jiraComponent.description,
            self: jiraComponent.self,
            issue_id: issueId
        };
    }

    // Map Jira fix version to database fix version
    static mapFixVersion(jiraFixVersion: any, projectId: string): DatabaseFixVersion {
        return {
            id: jiraFixVersion.id,
            self: jiraFixVersion.self,
            name: jiraFixVersion.name,
            description: jiraFixVersion.description,
            archived: jiraFixVersion.archived,
            released: jiraFixVersion.released,
            release_date: jiraFixVersion.releaseDate ? new Date(jiraFixVersion.releaseDate) : new Date(),
            project_id: projectId
        };
    }

    // Map Jira issue to database issue
    static mapIssue(jiraIssue: any): DatabaseIssue {
        // Handle both formats: with fields wrapper and without
        const fields = jiraIssue.fields || jiraIssue;

        // Extract custom fields (exclude standard fields)
        const customFields: any = {};
        const standardFields = [
            'summary', 'description', 'status', 'assignee', 'reporter', 'labels',
            'priority', 'created', 'updated', 'issuetype', 'project', 'fixVersions',
            'components', 'customfield_10014', 'customfield_10011'
        ];

        if (fields && typeof fields === 'object') {
            for (const [key, value] of Object.entries(fields)) {
                if (!standardFields.includes(key) && key.startsWith('customfield_')) {
                    customFields[key] = value;
                }
            }
        }

        // Parse dates
        const created = new Date(fields.created || jiraIssue.created);
        const updated = new Date(fields.updated || jiraIssue.updated);

        // Calculate resolved_date based on changelog and current status
        let resolvedDate: Date | null = null;
        const currentStatus = fields.status?.name || '';

        // Only set resolved_date if current status is Closed or Resolved
        if (currentStatus === 'Closed' || currentStatus === 'Resolved') {
            // Try to find the exact date when status changed to Closed/Resolved from changelog
            const changelogs = jiraIssue.changelogs || [];
            for (const changelog of changelogs) {
                if (changelog.items && Array.isArray(changelog.items)) {
                    for (const item of changelog.items) {
                        if (item.field === 'status' &&
                            (item.to_string === 'Closed' || item.to_string === 'Resolved')) {
                            resolvedDate = new Date(changelog.created);
                            break;
                        }
                    }
                }
                if (resolvedDate) break;
            }

            // If not found in changelog, use updated date as fallback
            if (!resolvedDate) {
                resolvedDate = updated;
            }
        }

        const result: DatabaseIssue = {
            id: this.nullify(jiraIssue.id) || `issue_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            key: this.nullify(jiraIssue.key),
            self: this.nullify(jiraIssue.self || jiraIssue.url),
            summary: this.nullify(fields.summary || jiraIssue.summary || ''),
            status_name: this.nullify(fields.status?.name),
            project_id: this.nullify(fields.project?.id), // Don't use 'unknown' to avoid foreign key constraint
            project_key: this.nullify(fields.project?.key),
            project_name: this.nullify(fields.project?.name),
            created,
            updated,
            resolved_date: resolvedDate, // Only set if status is Closed/Resolved
            description: this.nullify(fields.description),
            issue_type_name: this.nullify(fields.issuetype?.name || fields.issue_type?.name),
            priority_name: this.nullify(fields.priority?.name),
            labels: this.nullify(JSON.stringify(fields.labels || [])),
            subtasks: this.nullify(JSON.stringify(fields.subtasks || [])),
            changelog: null // Remove changelog from issues table - will be handled separately
        };

        // Handle assignee - check both fields.assignee and direct jiraIssue.assignee
        const assignee = fields.assignee || jiraIssue.assignee;
        if (assignee && (assignee.displayName || assignee.display_name || assignee.name)) {
            const assigneeName = assignee.displayName || assignee.display_name || assignee.name;
            result.assignee_name = this.nullify(assigneeName);
        }

        // Handle reporter - check both fields.reporter and direct jiraIssue.reporter
        const reporter = fields.reporter || jiraIssue.reporter;
        if (reporter && (reporter.displayName || reporter.display_name || reporter.name)) {
            const reporterName = reporter.displayName || reporter.display_name || reporter.name;
            result.reporter_name = this.nullify(reporterName);
        }
        // fix_versions is already handled as JSON field above

        return result;
    }


    // Extract status change changelogs from issue
    static extractStatusChangeChangelogs(jiraIssue: any): DatabaseChangelog[] {
        const changelogs: DatabaseChangelog[] = [];
        const issueId = jiraIssue.id;
        const rawChangelogs = jiraIssue.changelogs || [];

        for (const changelog of rawChangelogs) {
            // Only process changelogs that have status changes
            if (changelog.items && Array.isArray(changelog.items)) {
                // Find all status change items in this changelog
                const statusChangeItems = changelog.items.filter((item: any) => item.field === 'status');

                // Create a separate changelog record for each status change
                for (const statusItem of statusChangeItems) {
                    const statusChangelog: DatabaseChangelog = {
                        issue_id: issueId,
                        created: new Date(changelog.created),
                        author_name: changelog.author?.name || changelog.author?.display_name || changelog.authorId || 'unknown',
                        author_email: changelog.author?.email || changelog.author?.emailAddress || '',
                        from_status: statusItem.from_string || statusItem.from || null,
                        to_status: statusItem.to_string || statusItem.to || null,
                        from_id: statusItem.from_id || statusItem.fromId || null,
                        to_id: statusItem.to_id || statusItem.toId || null
                    };
                    changelogs.push(statusChangelog);
                }
            }
        }

        return changelogs;
    }

    // Map Jira subtask to database subtask
    static mapSubtask(jiraSubtask: any, issueId: string): DatabaseSubtask {
        return {
            id: jiraSubtask.id,
            name: jiraSubtask.name,
            self: jiraSubtask.self,
            issue_id: issueId
        };
    }

    // Map Jira issue labels to database labels
    static mapLabels(jiraIssue: any): DatabaseLabel[] {
        const fields = jiraIssue.fields || jiraIssue;
        if (!fields || !fields.labels) {
            return [];
        }
        return fields.labels.map((label: string) => ({
            issue_id: jiraIssue.id,
            label_name: label
        }));
    }

    // Map Jira issue fix versions to database issue fix versions
    static mapIssueFixVersions(jiraIssue: any): DatabaseIssueFixVersion[] {
        const fields = jiraIssue.fields || jiraIssue;
        return (fields.fixVersions || []).map((fixVersion: any) => ({
            issue_id: jiraIssue.id,
            fix_version_id: fixVersion.id
        }));
    }

    // Map Jira issue components to database components
    static mapIssueComponents(jiraIssue: any): DatabaseComponent[] {
        const fields = jiraIssue.fields || jiraIssue;
        return (fields.components || []).map((component: any) =>
            this.mapComponent(component, jiraIssue.id)
        );
    }

    // Map Jira comment to database comment
    static mapComment(jiraComment: any, issueId: string): DatabaseComment {
        return {
            issue_id: issueId,
            comment_id: jiraComment.id,
            author_name: jiraComment.author?.displayName || jiraComment.author?.name || 'Unknown',
            author_email: jiraComment.author?.emailAddress || jiraComment.author?.email || '',
            body: jiraComment.body || '',
            created: new Date(jiraComment.created),
            updated: new Date(jiraComment.updated)
        };
    }

    // Map multiple Jira comments to database comments
    static mapMultipleComments(jiraComments: any[], issueId: string): DatabaseComment[] {
        return jiraComments.map(comment => this.mapComment(comment, issueId));
    }

    // Extract all entities from a Jira issue
    static extractAllEntities(jiraIssue: any, comments?: any[]) {
        const entities = {
            issue: this.mapIssue(jiraIssue),
            labels: this.mapLabels(jiraIssue),
            components: this.mapIssueComponents(jiraIssue),
            issueFixVersions: this.mapIssueFixVersions(jiraIssue),
            changelogs: this.extractStatusChangeChangelogs(jiraIssue),
            comments: comments ? this.mapMultipleComments(comments, jiraIssue.id) : []
        };

        // Handle both formats: with fields wrapper and without
        const fields = jiraIssue.fields || jiraIssue;

        // Extract users - check both fields and direct jiraIssue
        const users: DatabaseUser[] = [];
        const assignee = fields.assignee || jiraIssue.assignee;
        if (assignee) {
            users.push(this.mapUser(assignee));
        }
        const reporter = fields.reporter || jiraIssue.reporter;
        if (reporter) {
            users.push(this.mapUser(reporter));
        }

        // Extract project - handle case where project might not exist
        let project: DatabaseProject;
        if (fields.project) {
            const projectData: JiraProject = {
                id: fields.project.id,
                key: fields.project.key,
                name: fields.project.name,
                self: (fields.project as any).self || fields.project.id,
                projectTypeKey: (fields.project as any).projectTypeKey,
                archived: (fields.project as any).archived,
                projectCategory: (fields.project as any).projectCategory
            };
            project = this.mapProject(projectData);
        } else {
            // Extract project key from issue key (e.g., "ADVANCED_A-112" -> "ADVANCED_A")
            const issueKey = jiraIssue.key || '';
            const projectKey = issueKey.split('-')[0] || 'unknown';

            // Create project with extracted key - this will be updated when projects are saved
            project = {
                id: `project_${projectKey}`, // Use prefixed key to avoid conflicts
                key: projectKey,
                name: `${projectKey} Project`, // Generic name since we don't have real project name
                self: projectKey,
                project_type_key: 'unknown',
                archived: false
            };
        }

        // Status is now handled directly in mapIssue as status_name

        // Extract fix versions
        const fixVersions = (fields.fixVersions || []).map((fv: any) =>
            this.mapFixVersion(fv, fields.project?.id || 'unknown')
        );

        return {
            ...entities,
            users,
            project,
            fixVersions
        };
    }

    // Extract all entities from search results
    static extractAllEntitiesFromSearch(searchResult: JiraSearchResult) {
        const allEntities = {
            issues: [] as DatabaseIssue[],
            users: [] as DatabaseUser[],
            projects: [] as DatabaseProject[],
            fixVersions: [] as DatabaseFixVersion[],
            components: [] as DatabaseComponent[],
            labels: [] as DatabaseLabel[],
            issueFixVersions: [] as DatabaseIssueFixVersion[],
            changelogs: [] as DatabaseChangelog[]
        };

        const uniqueUsers = new Map<string, DatabaseUser>();
        const uniqueProjects = new Map<string, DatabaseProject>();
        const uniqueFixVersions = new Map<string, DatabaseFixVersion>();

        for (const jiraIssue of searchResult.issues) {
            const entities = this.extractAllEntities(jiraIssue);

            // Add issue
            allEntities.issues.push(entities.issue);

            // Add unique users
            for (const user of entities.users) {
                const userKey = user.email_address || user.display_name || 'unknown';
                if (!uniqueUsers.has(userKey)) {
                    uniqueUsers.set(userKey, user);
                    allEntities.users.push(user);
                }
            }

            // Add unique project
            if (!uniqueProjects.has(entities.project.id)) {
                uniqueProjects.set(entities.project.id, entities.project);
                allEntities.projects.push(entities.project);
            }

            // Status is now handled directly in mapIssue as status_name

            // Add unique fix versions
            for (const fixVersion of entities.fixVersions) {
                if (!uniqueFixVersions.has(fixVersion.id)) {
                    uniqueFixVersions.set(fixVersion.id, fixVersion);
                    allEntities.fixVersions.push(fixVersion);
                }
            }

            // Add components
            allEntities.components.push(...entities.components);

            // Add labels
            allEntities.labels.push(...entities.labels);

            // Add issue fix versions
            allEntities.issueFixVersions.push(...entities.issueFixVersions);

            // Add changelogs
            allEntities.changelogs.push(...entities.changelogs);
        }

        return allEntities;
    }
}

export default JiraDataMapper;

